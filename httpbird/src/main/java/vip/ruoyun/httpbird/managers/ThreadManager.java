package vip.ruoyun.httpbird.managers;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * Created by ruoyun on 14-7-28. * 下载线程池管理类 (Description) */public class ThreadManager {    private ThreadManager() {    }    /**     * 获取下载线程     */    public static ThreadPoolProxy getThreadPool() {        return ThreadPoolSingletonHolder.mThreadPool;    }    /**     * 3个线程     */    private static class ThreadPoolSingletonHolder {        public static ThreadPoolProxy mThreadPool = new ThreadPoolProxy(5, 10, 5L);    }    public static class ThreadPoolProxy {        private ThreadPoolExecutor mPool;// 线程池        private int mCorePoolSize;// 线程池维护线程的最少数量        private int mMaximumPoolSize;// 线程池维护线程的最大数量        private long mKeepAliveTime;// 线程池维护线程所允许的空闲时间        private ThreadPoolProxy(int corePoolSize, int maximumPoolSize, long keepAliveTime) {            mCorePoolSize = corePoolSize;            mMaximumPoolSize = maximumPoolSize;            mKeepAliveTime = keepAliveTime;        }        /**         * 执行任务，当线程池处于关闭，将会重新创建新的线程池         */        public synchronized Future<?> execute(Runnable run) {            if (run == null) {                return null;            }            if (mPool == null || mPool.isShutdown()) {                mPool = new ThreadPoolExecutor(//                        mCorePoolSize,//                        mMaximumPoolSize,//                        mKeepAliveTime, //                        TimeUnit.MILLISECONDS,//                        new LinkedBlockingQueue<Runnable>(),// 无限队列,先进先出                        Executors.defaultThreadFactory(),//                        new ThreadPoolExecutor.AbortPolicy());// 如果有错误的话，直接退出            }            // mPool.execute(run);            return mPool.submit(run);        }        /**         * 取消线程池中某个还未执行的任务         */        public void cancel(Runnable run) {            if (mPool != null && (!mPool.isShutdown() || mPool.isTerminating())) {                if (mPool.getQueue().contains(run)) {// 判断是否有包含这个任务                    mPool.getQueue().remove(run);                }            }        }        /**         * 取消线程池中某个正在执行的任务         */        public synchronized void cancel(Future<?> submit) {            if (mPool != null && (!mPool.isShutdown() || mPool.isTerminating())) {                if (submit.isDone()) {                    submit.cancel(true);                }            }        }        /**         * 判断线程池中是否含有某个还未执行的任务         */        public boolean contains(Runnable run) {            if (mPool != null && (!mPool.isShutdown() || mPool.isTerminating())) {                return mPool.getQueue().contains(run);            } else {                return false;            }        }        /**         * 立刻关闭线程池，并且正在执行的任务也将会被中断         */        public void stop() {            if (mPool != null && (!mPool.isShutdown() || mPool.isTerminating())) {                mPool.shutdownNow();            }        }        /**         * 平缓关闭单任务线程池，但是会确保所有已经加入的任务都将会被执行完毕才关闭         */        public synchronized void shutdown() {            if (mPool != null && (!mPool.isShutdown() || mPool.isTerminating())) {                mPool.shutdown();            }        }        public synchronized boolean isShutDown() {            return mPool.isShutdown();        }    }}